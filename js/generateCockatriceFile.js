window.onload = initialize;

/**
 * Application setup.
 */
function initialize() {
    CARDS = CARDS.concat(FICG_CARDS);
    CARDS = CARDS.concat(IPU_CARDS);

    const htmlElement = document.querySelector('html');
    htmlElement.style.fontFamily = 'monospace';
    let sets = undefined;
    const allSetsName = '[All PonyMTG sets]';

    information = getInformation(CARDS);

    global.urlParameters = getUrlParameters();
    if (Object.keys(global.urlParameters).length > 0) {
        if (global.urlParameters.set !== undefined) {
            if (information.sets.indexOf(global.urlParameters.set) !== -1) {
                sets = [global.urlParameters.set];
            }
            else if (global.urlParameters.set === allSetsName) {
                sets = information.sets;
            }
        }
    }

    if (sets !== undefined) {
        let setName = undefined;
        if (sets.length === 1) {
            setName = sets[0];
        }
        else if (global.urlParameters.set === allSetsName) {
            setName = allSetsName;
        }

        let cockatriceXml = '';
        cockatriceXml += getCockatriceXml(sets);

        let headerComment = '';
        headerComment += '<!--\n';
        headerComment += '    Cockatrice XML file for custom MtG set "'
            + setName + '"\n';
        headerComment += '    Generated by PonyMTG on ' + (new Date()) + '\n';
        headerComment += '\n';
        headerComment += '    Save this text data as a file with a .xml'
            + ' extension, then use Cockatrice\'s Import feature to add the'
            + ' file to your local Cockatrice database.\n';
        headerComment += '-->\n';

        let cockatriceXmlLines = cockatriceXml.split('\n');
        cockatriceXmlLines.splice(1, 0, headerComment);

        cockatriceXml = cockatriceXmlLines.join('\n');

        let cockatriceXmlHtml = '';
        cockatriceXmlHtml += escapeXml(cockatriceXml);
        cockatriceXmlHtml = cockatriceXmlHtml.replace(/ /g, '&nbsp;');
        cockatriceXmlHtml = cockatriceXmlHtml.replace(/\n/g, '<br />');
        htmlElement.innerHTML = cockatriceXmlHtml;
    }
    else {
        const errorMessageElement = document.createElement('p');
        errorMessageElement.innerHTML = 'ERROR: Couldn\'t find a set for which'
            + ' to generate Cockatrice data. The URL might be incorrect.';
        htmlElement.appendChild(errorMessageElement);
    }
}

function getCockatriceXml(sets) {
    const cockatriceDbVersion = '4';

    // Get a list of set codes (a set code is the short, usually three-letter
    // code that can be used to refer to the set, eg. "AWW".
    const setCodes = generateUniqueSetCodes(sets);

    // Get a list of unique card names categorized by set. Cockatrice currently
    // has a deficiency whereby it cannot display different images for cards
    // that have the same name (even if those cards are obviously from
    // different sets). To get around this, we are generating unique names for
    // all cards in the specified sets, and using those in place of the actual
    // names.

    // Note that we're making the slightly dangerous assumption that the
    // ordering of the cards in each set contained within this object, will be
    // the same as the ordering of the cards that we're about to run through to
    // generate the XML. We make that assumption in order to be able to match
    // card name to unique name by the index at which each appear in their
    // respective sets. If the ordering is _not_ the same, then cards will be
    // matched to the wrong unique names.
    const uniqueCardNamesBySet = getUniqueCardNames(sets);

    const setSpecs = [];
    for (let i=0; i < sets.length; i++) {
        const setName = sets[i];
        const setCode = setCodes[i];
        const setSpec = {
            'tag': 'set',
            'contents': [
                {
                    'tag': 'name',
                    'contents': [setCode]
                },
                {
                    'tag': 'longname',
                    'contents': [setName]
                },
                {
                    'tag': 'settype',
                    'contents': ['Expansion']
                },
            ]
        };
            
        setSpecs.push(setSpec);
    }

    const cardSpecs = [];
    for (let i=0; i < sets.length; i++) {
        const setName = sets[i];
        const setCode = setCodes[i];
        const cards = getCardsFilteredBySet(CARDS, [setName]);

        // Add card data for each card in the set.
        for (let j=0; j < cards.length; j++) {
            const card = cards[j];

            const cardSpec = {
                'tag': 'card',
                'contents': []
            };

            const uniqueCardName = uniqueCardNamesBySet[card.set][j];
            const nameSpec = {'tag': 'name', 'contents': [uniqueCardName]};
            cardSpec.contents.push(nameSpec);

            if (card.text !== undefined) {
                const textSpec = {'tag': 'text', 'contents': [card.text]};
                cardSpec.contents.push(textSpec);
            }

            const propSpec = {
                'tag': 'prop',
                'contents': []
            };

            let layout = 'normal';
            let side = 'front';

            if (card.cost !== undefined) {
                let manaCost = '';
                manaCost = card.cost;

                if (card.cost2 !== undefined) {
                    manaCost += ' // ' + card.cost2;
                }

                manaCost = convertManaCostToCockatriceFormat(manaCost);
                const manaCostSpec = {
                    'tag': 'manacost',
                    'contents': [manaCost]
                };

                propSpec.contents.push(manaCostSpec);
            }
            
            let type = '';
            if (card.supertype !== undefined) {
                let mainType = card.supertype;
                type = mainType;

                if (card.subtype !== undefined) {
                    type += ' — ' + card.subtype;
                }

                if (card.supertype2 !== undefined) {
                    layout = 'split';
                    mainType += ' // ' + card.supertype2;
                    if (card.subtype2 !== undefined) {
                        type += ' // ' + card.supertype2 + ' — '
                            + card.subtype2;
                    }
                }

                const mainTypeSpec = {
                    'tag': 'maintype',
                    'contents': [mainType]
                };
                const typeSpec = {'tag': 'type', 'contents': [type]};

                propSpec.contents.push(mainTypeSpec);
                propSpec.contents.push(typeSpec);
            }

            const cmc = getCardConvertedManaCost(card);
            const cmcSpec = {'tag': 'cmc', 'contents': [cmc]};
            propSpec.contents.push(cmcSpec);

            // Get a list of colors present in this card.
            let colors = [];
            const manaTypes = getCardManaTypes(card);
            const manaTypesToSymbols
                = global.mappings.manaTypesToRepresentativeSymbols;

            for (let k = 0; k < manaTypes.length; k++) {
                const manaType = manaTypes[k];
                if (manaTypesToSymbols[manaType] !== undefined) {
                    const color = manaTypesToSymbols[manaType];
                    if (['W','U','B','R','G'].indexOf(color) === -1) {
                        // If it's not a WUBRG color, ignore it.
                        continue;
                    }
                    colors.push(color);
                }
            }
            const colorsSpec = {'tag': 'colors'};
            if (colors.length > 0) {
                colorsSpec.contents =  [colors.join('')];
            }
            propSpec.contents.push(colorsSpec);

            if (card.pt !== undefined) {
                const ptSpec = {'tag': 'pt', 'contents': [card.pt]};
                propSpec.contents.push(ptSpec);
            }
            
            if (card.loyalty !== undefined) {
                const loyaltySpec = {
                    'tag': 'loyalty',
                    'contents': [card.loyalty]
                };
                propSpec.contents.push(loyaltySpec);
            }
            
            // Cockatrice has a special `tablerow` parameter which it uses
            // internally to decide where cards should be placed on the board.
            // This generally depends on the card's type.
            let tablerow = 1;
            if (/Land/i.test(type)) {
               tablerow = 0; 
            }
            else if (/Creature/i.test(type)) {
               tablerow = 2; 
            }
            else if (/Instant/i.test(type) || /Sorcery/i.test(type)) {
               tablerow = 3; 
            }
            const tableRowSpec = {
                'tag': 'tablerow',
                'contents': [tablerow]
            };
            cardSpec.contents.push(tableRowSpec);

            // If the card transforms into something (ie. it's double-sided),
            // add that to the `<related>` tag. There is also a
            // `<reverse-related>` tag, but the Cockatrice XML guidelines state
            // that you only need to create one of the relations, not both.
            //
            // Also set the appropriate card side if it's the reverse side of a
            // transforming card.
            let related = undefined;
            let reverseRelated = undefined;
            if (card.transformsInto !== undefined) {
                const relatedSpec = {
                    'tag': 'related',
                    'contents': [card.transformsInto]
                };
                cardSpec.contents.push(relatedSpec);
                layout = 'transform';
            }
            if (card.transformsFrom !== undefined) {
                side = 'back';
                layout = 'transform';
                const reverseRelatedSpec = {
                    'tag': 'reverse-related',
                    'contents': [card.transformsFrom]
                };
                cardSpec.contents.push(reverseRelatedSpec);
            }

            propSpec.side = side;
            const sideSpec = {'tag': 'side', 'contents': [side]};
            propSpec.contents.push(sideSpec);

            propSpec.layout = layout;
            const layoutSpec = {'tag': 'layout', 'contents': [layout]};
            propSpec.contents.push(layoutSpec);
            
            // Create a `<set>` tag. In Cockatrice XML v4, a card can have
            // multiple set tags, as it may have appeared in more than one set
            // (and might have a different rarity in one set compared to
            // another). For PonyMTG, we implicitly assume that every card
            // appears in just one set, so we only need one set tag.
            //
            // This is also where we can add a link to the card image, if it has
            // one.
            const setSpec = {
                'tag': 'set',
                'contents': [setCode]
            };

            if (card.image !== undefined) {
                let baseUrl = window.location.origin;
                baseUrl += window.location.pathname
                    .split('/')
                    .slice(0, -1)
                    .join('/');

                if (SETS[card.set] !== undefined) {
                    if (SETS[card.set].path !== undefined) {
                        picUrl = baseUrl + '/' + global.paths.sets + '/'
                            + SETS[card.set].path+'/'+card.image;

                        setSpec.attributes = {'picurl': picUrl};
                    }
                }
            }

            cardSpec.contents.push(propSpec);
            cardSpec.contents.push(setSpec);
            cardSpecs.push(cardSpec);
        }
    }

    const cockatriceSpec = {
        'tag': 'cockatrice_carddatabase',
        'attributes': {'version': cockatriceDbVersion},
        'contents': [
            {
                'tag': 'sets',
                'contents': setSpecs
            },
            {
                'tag': 'cards',
                'contents': cardSpecs
            },
        ]
    };

    const header = '<?xml version="1.0" encoding="UTF-8"?>\n';
    let xml = createXmlFromSpec(cockatriceSpec);
    xml = header + xml;

    return xml;
}

/**
 * Given a string that may contain mana costs in the FICG-style format, convert
 * them to the Cockatrice-style format.
 *
 * This only really applies to the hybrid mana symbols: for example, (wu) in
 * FICG translates to {W/U} in Cockatrice format.
 *
 * @param {string} string
 * @return {string}
 */
function convertManaCostToCockatriceFormat(string) {
    const pattern = /(\(\w\/?\w\))/g;
    let tokens = string.split(pattern);

    for (let i = 0; i < tokens.length; i++) {
        if (i % 2 === 0) {
            continue;
        }

        let oldHybridMana = tokens[i];
        oldHybridMana = oldHybridMana.replace('/', '');
        const chars = oldHybridMana.split('');
        const newHybridMana = `{${chars[1]}/${chars[2]}}`;
        tokens[i] = newHybridMana;
    }

    const newManaCost = tokens.join('').toUpperCase();
    return newManaCost;
}

/**
 * Given a suitably prepared specification object, output a corresponding XML
 * string.
 *
 * A specification object represents a single XML tag, which may have attributes
 * and may enclose any sequence of contents. Contents can be consist of any mix
 * of string values or additional specification objects.
 *
 * Example:
 *
 *     {
 *         'tag': 'example',
 *         'attributes': {
 *             'attribute1': 'value1',
 *             'attribute2': 'value2',
 *         },
 *         'contents': [
 *             {
 *                 'tag': 'example2',
 *                 'contents': ['value']
 *             }
 *         ]
 *     }
 *
 * @param {Object} spec
 * @param {number} level
 * @return {string}
 */
function createXmlFromSpec(spec, level = 0) {
    const tag = spec.tag;
    const attributes = spec.attributes ? spec.attributes : {};
    const contents = spec.contents ? spec.contents : [];

    const indentSpaces = 4;
    const indent = ' '.repeat(level * indentSpaces);

    let xml = '';

    let attributeString = '';
    if (Object.keys(attributes).length > 0) {
        attributeString = Object.keys(attributes).map(
            function (key) {
                return `${key}="${attributes[key]}"`;
            }
        ).join(' ');

        attributeString = ' ' + attributeString;
    }
    if (contents.length === 0) {
        xml += `${indent}<${tag}${attributeString}></${tag}>`;
    } else if (contents.length === 1 && !UTIL.isObject(contents[0])) {
        let content = '' + contents[0];
        content = escapeXml(content);
        xml += `${indent}<${tag}${attributeString}>${content}</${tag}>`;
    } else {
        xml += `${indent}<${tag}${attributeString}>\n`;
        contents.forEach(
            function (item) {
                if (UTIL.isObject(item)) {
                    xml += createXmlFromSpec(item, level + 1) + '\n';
                } else {
                    xml += `${indent}${' '.repeat(indentSpaces)}${item}\n`;
                }
            }
        );
        xml += `${indent}</${tag}>`;
    }

    return xml;
}

/**
 * Escape XML entities in a string.
 *
 * @param {string} string
 * @return {string}
 */
function escapeXml(string) {
    let escapedString = string;

    const xmlEntityMappings = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        //'\'': '&apos;',
    }

    const charactersToBeEscaped = Object.keys(xmlEntityMappings);

    charactersToBeEscaped.forEach(
        function (character) {
            const entityToReplaceWith = xmlEntityMappings[character];
            const xmlEntityEscapeRegex = new RegExp(character, 'g');
            escapedString = escapedString.replace(
                xmlEntityEscapeRegex,
                entityToReplaceWith
            );
        }
    );

    return escapedString;
}
